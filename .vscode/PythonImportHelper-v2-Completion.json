[
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "TIMESTAMP",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "HTTP",
        "importPath": "email.policy",
        "description": "email.policy",
        "isExtraImport": true,
        "detail": "email.policy",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "mode",
        "importPath": "turtle",
        "description": "turtle",
        "isExtraImport": true,
        "detail": "turtle",
        "documentation": {}
    },
    {
        "label": "pos",
        "importPath": "turtle",
        "description": "turtle",
        "isExtraImport": true,
        "detail": "turtle",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Response",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Body",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "psycopg2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psycopg2",
        "description": "psycopg2",
        "detail": "psycopg2",
        "documentation": {}
    },
    {
        "label": "RealDictCursor",
        "importPath": "psycopg2.extras",
        "description": "psycopg2.extras",
        "isExtraImport": true,
        "detail": "psycopg2.extras",
        "documentation": {}
    },
    {
        "label": "models",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "schemas",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "engine",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "get_db",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Post",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "SQLALCHEMY_DATABASE_URL",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "SQLALCHEMY_DATABASE_URL = 'postgresql://postgres:password@localhost/postgres'\n# The 'create_engine' function initializes a connection to the database.\n# The engine serves as the source of connectivity to our database.\nengine = create_engine(SQLALCHEMY_DATABASE_URL)\n# To interact with the database, rather than using the engine directly,\n# we use a 'Session'. The 'sessionmaker' function creates a factory for sessions.\n# 'autocommit' being False means data won't be saved unless we explicitly call commit.\n# 'autoflush' being False means SQLAlchemy won't automatically flush (i.e., write/sync) changes to the database unless explicitly asked.\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n# The 'declarative_base' function creates a base class for our models.",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "engine = create_engine(SQLALCHEMY_DATABASE_URL)\n# To interact with the database, rather than using the engine directly,\n# we use a 'Session'. The 'sessionmaker' function creates a factory for sessions.\n# 'autocommit' being False means data won't be saved unless we explicitly call commit.\n# 'autoflush' being False means SQLAlchemy won't automatically flush (i.e., write/sync) changes to the database unless explicitly asked.\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n# The 'declarative_base' function creates a base class for our models.\n# This base class will contain metadata about our tables and columns and provide the ability to generate SQL queries.\n# All the ORM classes/models we define will inherit from this base class, ensuring they are mapped to the right tables.\nBase = declarative_base()",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n# The 'declarative_base' function creates a base class for our models.\n# This base class will contain metadata about our tables and columns and provide the ability to generate SQL queries.\n# All the ORM classes/models we define will inherit from this base class, ensuring they are mapped to the right tables.\nBase = declarative_base()\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "Base = declarative_base()\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "find_post",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def find_post(id: str):\n    for post in my_posts:\n        if post['id']==int(id):\n            return post\ndef find_post_index(id: int)->int:\n    \"\"\"\n    Returns the index of the post with given index\"\"\"\n    for i in range(len(my_posts)):\n        if my_posts[i]['id']==id:\n            return i",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "find_post_index",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def find_post_index(id: int)->int:\n    \"\"\"\n    Returns the index of the post with given index\"\"\"\n    for i in range(len(my_posts)):\n        if my_posts[i]['id']==id:\n            return i\n#TEST ONE: db.query(models.Post).all() ->\n# Tapping into database object and query the Post table and get all posts\n#returns the SQL query db.query(models.Post)\n@app.get(\"/\")",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "get_posts",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def get_posts(db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"SELECT * from posts\"\"\")\n    # posts=cursor.fetchall()\n    posts= db.query(models.Post).all()\n    return posts\n    # Fast api will auto serialize my_posts into JSON\n@app.post(\"/post\",status_code=status.HTTP_201_CREATED, response_model=schemas.PostResponse)  \ndef create_posts(post: schemas.PostCreate, db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"INSERT INTO posts (title, content, published)\n    #                VALUES (%s, %s, %s) RETURNING * \"\"\", (post.title, post.content, post.published))",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "create_posts",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def create_posts(post: schemas.PostCreate, db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"INSERT INTO posts (title, content, published)\n    #                VALUES (%s, %s, %s) RETURNING * \"\"\", (post.title, post.content, post.published))\n    # new_post = cursor.fetchone()\n    # conn.commit()\n    # new_post=models.Post(title=post.title, content=post.content, published=post.published)\n    new_post=models.Post(**post.model_dump()) #Same as above, we unpacked\n    db.add(new_post) #add to database\n    db.commit()\n    db.refresh(new_post) # When you call db.refresh(new_post),",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "get_latest_post",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def get_latest_post(db: Session = Depends(get_db)):\n    post = my_posts[len(my_posts)-1]\n    return {\"detail\": post}\n@app.get(\"/posts/{id}\", response_model=schemas.PostResponse)\ndef get_post(id:int, response: Response, db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"SELECT * FROM posts where id = %s\"\"\",(str(id)))\n    # post=cursor.fetchone()\n    # conn.commit()\n# filter is equivalent of where\n    post = db.query(models.Post).filter(models.Post.id==id).first()",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "get_post",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def get_post(id:int, response: Response, db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"SELECT * FROM posts where id = %s\"\"\",(str(id)))\n    # post=cursor.fetchone()\n    # conn.commit()\n# filter is equivalent of where\n    post = db.query(models.Post).filter(models.Post.id==id).first()\n    if not post:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,\n                            detail=f\"Post with id {id} was not found\")\n    return post",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "delete_post",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def delete_post(id: int, db: Session = Depends(get_db)):\n    \"\"\"delete the post\"\"\"\n    #find the index of the post in the array with the required ID\n    # cursor.execute(\"\"\"DELETE FROM posts WHERE id = %s returning *\"\"\", (str(id)))\n    # deleted_post=cursor.fetchone()\n    # conn.commit()\n    post_query=db.query(models.Post).filter(models.Post.id == id)\n    if post_query.first() ==None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"post with id {id} does not exist\")\n    post_query.delete(synchronize_session=False)",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "delete_all",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def delete_all(db : Session= Depends(get_db)):\n    post_query = db.query(models.Post)\n    post_query.delete(synchronize_session=False)\n    db.commit()\n    return Response(status_code= status.HTTP_204_NO_CONTENT)\n@app.put(\"/posts/{id}\")\ndef update_post(id: int, post: schemas.PostCreate, db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"UPDATE posts SET title = %s, content =  %s, published = %s WHERE id = %s RETURNING *\"\"\", (post.title, post.content, post.published, (str(id))))\n    # updated_post=cursor.fetchone()\n    post_query= db.query(models.Post).filter(models.Post.id == id)",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "update_post",
        "kind": 2,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "def update_post(id: int, post: schemas.PostCreate, db: Session = Depends(get_db)):\n    # cursor.execute(\"\"\"UPDATE posts SET title = %s, content =  %s, published = %s WHERE id = %s RETURNING *\"\"\", (post.title, post.content, post.published, (str(id))))\n    # updated_post=cursor.fetchone()\n    post_query= db.query(models.Post).filter(models.Post.id == id)\n    post_inst=post_query.first()\n    if post_inst==None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"post with id{id} does not exist\")\n    post_query.update({**post.model_dump()}, synchronize_session=False)\n    db.commit()\n    # conn.commit()",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "app = FastAPI()\nmodels.Base.metadata.create_all(bind= engine)\n# with psycopg.connect(host=\"localhost\",dbname=\"postgres\", user=\"postgres\", password=\"password\") as conn:\n#     with conn.cursor(row_factory=psycopg.AsyncCursor) as curr:\n#         print(\"Database connection was successful\")\nwhile True:\n    try:\n        conn = psycopg2.connect(host='localhost', dbname='postgres', user='postgres', password = 'password', cursor_factory=RealDictCursor)\n        cursor = conn.cursor()\n        print(\"Database connection successful\")",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "my_posts",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "my_posts = [{\"title\": \"Title1\", \"content\": \"Content1\", \"id\":1}, {\"title\": \"Title2\", \"content\": \"Content2\", \"id\":2}]\ndef find_post(id: str):\n    for post in my_posts:\n        if post['id']==int(id):\n            return post\ndef find_post_index(id: int)->int:\n    \"\"\"\n    Returns the index of the post with given index\"\"\"\n    for i in range(len(my_posts)):\n        if my_posts[i]['id']==id:",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "Post",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class Post(Base):\n    #what do we wanna call this table in postgres? We have a class name called Post that only python knows but we can specify a specific name in postgres\n    __tablename__ = \"posts\"\n    #to create a column we have to import Column from SQLAlchemy\n    id = Column(Integer, primary_key=True, nullable=False)\n    title = Column(String, nullable=False)\n    content = Column(String, nullable=False)\n    published = Column(Boolean, server_default='TRUE')\n    created_at = Column(TIMESTAMP(timezone=True), nullable=False, server_default=text('now()'))",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "PostBase",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class PostBase(BaseModel):\n    title: str\n    content: str\n    published: bool = True\nclass PostCreate(PostBase):\n   pass\nclass PostResponse(PostBase):\n    id: int\n    created_at: datetime\n    class Config:",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "PostCreate",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class PostCreate(PostBase):\n   pass\nclass PostResponse(PostBase):\n    id: int\n    created_at: datetime\n    class Config:\n        from_attributes = True",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "PostResponse",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class PostResponse(PostBase):\n    id: int\n    created_at: datetime\n    class Config:\n        from_attributes = True",
        "detail": "app.schemas",
        "documentation": {}
    }
]